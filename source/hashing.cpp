#include "stdafx.h"
#include "hashing.h"
#include "Utils.h"

#include <regex>
#include <cctype>
#include <map>

HashAlgoInfo SupportedHashes[] = {
	{ RHASH_CRC32,     L"CRC32",     L".sfv" },
	{ RHASH_MD5,       L"MD5",       L".md5" },
	{ RHASH_SHA1,      L"SHA1",      L".sha1" },
	{ RHASH_SHA256,    L"SHA-256",   L".sha256" },
	{ RHASH_SHA512,    L"SHA-512",   L".sha512" },
	{ RHASH_SHA3_512,  L"SHA3-512",  L".sha3" },
	{ RHASH_WHIRLPOOL, L"Whirlpool", L".wrpl" }
};

static bool IsSfvAlgo(rhash_ids algo)
{
	return (algo == RHASH_CRC32) || (algo == RHASH_CRC32C);
}

static bool IsComment(char* line)
{
	char* strPtr = line;
	while (strPtr && *strPtr)
	{
		char next = *strPtr;
		
		// Comments start with semicolon
		if (next == ';' || next == '#')
			return true;
		
		// Spaces are allowed before semicolon
		if (!isspace(next) && (next != '\t'))
			return false;

		strPtr++;
	}
	return true;
}

static std::wstring GetAlgoFileExt(rhash_ids algo)
{
	for (int i = 0; i < NUMBER_OF_SUPPORTED_HASHES; i++)
	{
		if (SupportedHashes[i].AlgoId == algo)
			return SupportedHashes[i].DefaultExt;
	}
	return L"";
}

HashAlgoInfo* GetAlgoInfo(rhash_ids algoId)
{
	int i = GetAlgoIndex(algoId);
	return i >= 0 ? &SupportedHashes[i] : nullptr;
}

int GetAlgoIndex(rhash_ids algoId)
{
	for (int i = 0; i < NUMBER_OF_SUPPORTED_HASHES; i++)
	{
		if (SupportedHashes[i].AlgoId == algoId)
			return i;
	}
	return -1;
}

int GetAlgoIndexByName(const wchar_t* name)
{
	for (int i = 0; i < NUMBER_OF_SUPPORTED_HASHES; i++)
	{
		if (SameText(SupportedHashes[i].AlgoName.c_str(), name))
			return i;
	}
	return -1;
}

//////////////////////////////////////////////////////////////////////////

void HashList::SetFileHash(const std::wstring &fileName, std::string hashVal, rhash_ids hashAlgo)
{
	int index = GetFileRecordIndex(fileName.c_str());
	if (index >= 0)
	{
		m_HashList[index].HashStr = hashVal;
	}
	else
	{
		FileHashInfo info;
		info.Filename = fileName;
		info.HashStr = hashVal;
		info.HashAlgo = hashAlgo;

		m_HashList.push_back(info);
	}
}

bool HashList::SaveHashesToFile(const std::wstring &filePath, FileHashList &hashList, UINT codepage, bool stripPathInfo)
{
	std::stringstream sstr;

	sstr << "; Generated by Integrity Checker Plugin (by Ariman)" << endl << endl;

	for (auto cit = hashList.cbegin(); cit != hashList.cend(); cit++)
	{
		const FileHashInfo& hashData = *cit;
		hashData.Serialize(sstr, codepage, stripPathInfo);
		sstr << endl;
	}

	string strData = sstr.str();
	return DumpStringToFile(strData, filePath.c_str());
}

bool HashList::SaveList( const wchar_t* filepath, UINT codepage )
{
	return SaveHashesToFile(filepath, m_HashList, codepage, false);
}

bool HashList::SaveListSeparate( const wchar_t* baseDir, UINT codepage, int &successCount, int &failCount )
{
	std::wstring dirName(baseDir);
	IncludeTrailingPathDelim(dirName);

	successCount = 0;
	failCount = 0;

	for (auto cit = m_HashList.cbegin(); cit != m_HashList.cend(); cit++)
	{
		const FileHashInfo& hashData = *cit;
		auto destFilePath = dirName + hashData.Filename + GetAlgoFileExt(hashData.HashAlgo);
		
		std::vector<FileHashInfo> saveData = { hashData };
		if (SaveHashesToFile(destFilePath, saveData, codepage, true))
			successCount++;
		else
			failCount++;
	}
	
	return (failCount == 0);
}

bool HashList::SaveListEachDir(const wchar_t* baseDir, UINT codepage, int &successCount, int &failCount)
{
	successCount = 0;
	failCount = 0;

	std::map<std::wstring, FileHashList> dirSort;
	for (auto it = m_HashList.begin(); it != m_HashList.end(); ++it)
	{
		const FileHashInfo& hashData = *it;
		
		auto slashPos = hashData.Filename.rfind('\\');
		auto dir = (slashPos == std::wstring::npos) ? L"" : hashData.Filename.substr(0, slashPos + 1);
		auto destPath = baseDir + dir + L"hashlist" + GetAlgoFileExt(hashData.HashAlgo);

		if (dirSort.count(destPath) == 0)
			dirSort[destPath] = FileHashList();

		FileHashList &vec = dirSort[destPath];
		vec.push_back(hashData);
	}

	for (auto it = dirSort.begin(); it != dirSort.end(); ++it)
	{
		auto destPath = it->first;
		auto items = it->second;

		if (items.empty()) continue;

		if (SaveHashesToFile(destPath, items, codepage, true))
			successCount++;
		else
			failCount++;
	}

	return (failCount == 0);
}

bool HashList::LoadList( const wchar_t* filepath, UINT codepage, bool merge )
{
	char readBuf[2048];
	FILE* inputFile;

	if (!merge)
		m_HashList.clear();

	if (_wfopen_s(&inputFile, filepath, L"r") != 0)
		return false;

	bool fres = true;
	rhash_ids listAlgo = RHASH_ALL_HASHES;
	HashListFormat listFormat = HLF_UNKNOWN;
	std::vector<FileHashInfo> parsedList;

	while (fgets(readBuf, sizeof(readBuf), inputFile))
	{
		// Just skipping comments and empty lines
		if (!readBuf[0] || IsComment(readBuf)) continue;

		TrimRight(readBuf);
		
		if (listFormat == HLF_UNKNOWN)
		{
			if (!DetectFormat(readBuf, codepage, filepath, listAlgo, listFormat))
			{
				fres = false;
				break;
			}
		}

		FileHashInfo fileInfo;
		bool lineParsed = false;

		switch (listFormat)
		{
		case HLF_BSD:
			lineParsed = TryParseBSD(readBuf, codepage, fileInfo);
			break;
		case HLF_SIMPLE:
			lineParsed = TryParseSimple(readBuf, codepage, listAlgo, fileInfo);
			break;
		case HLF_SFV:
			lineParsed = TryParseSfv(readBuf, codepage, listAlgo, fileInfo);
			break;
		}

		if (lineParsed)
		{
			parsedList.push_back(fileInfo);
		}
	}
	fclose(inputFile);

	if (fres)
	{
		m_HashList.insert(m_HashList.end(), parsedList.begin(), parsedList.end());
	}

	return fres;
}

int HashList::GetFileRecordIndex( const wchar_t* fileName ) const
{
	for (size_t i = 0; i < m_HashList.size(); i++)
	{
		const FileHashInfo& info = m_HashList[i];
		if (wcscmp(info.Filename.c_str(), fileName) == 0)
			return (int) i;
	}

	return -1;
}

bool HashList::DumpStringToFile(const std::string& data, const wchar_t* filePath)
{
	HANDLE hFile = CreateFile(filePath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (hFile == INVALID_HANDLE_VALUE) return false;

	DWORD writeSize = (DWORD)data.length();
	DWORD numWritten;
	
	bool retVal = WriteFile(hFile, data.c_str(), writeSize, &numWritten, NULL) && (numWritten == writeSize);
	
	CloseHandle(hFile);
	return retVal;
}

bool HashList::DetectFormat( const char* testStr, UINT codepage, const wchar_t* filePath, rhash_ids &foundAlgo, HashListFormat &listFormat )
{
	FileHashInfo fileInfo;

	if (TryParseBSD(testStr, codepage, fileInfo))
	{
		listFormat = HLF_BSD;
		foundAlgo = fileInfo.HashAlgo;
		return true;
	}

	// Some hashes have same length of hash string
	// In this case we will distinguish algorithm by file extension

	auto ext = ExtractFileExt(filePath);
	bool found = false;

	for (int i = 0; i < NUMBER_OF_SUPPORTED_HASHES; i++)
	{
		rhash_ids nextAlgo = SupportedHashes[i].AlgoId;
		if ((IsSfvAlgo(nextAlgo) && TryParseSfv(testStr, codepage, nextAlgo, fileInfo))
			|| (!IsSfvAlgo(nextAlgo) && TryParseSimple(testStr, codepage, nextAlgo, fileInfo)))
		{
			bool sameExt = (_wcsicmp(ext.c_str(), SupportedHashes[i].DefaultExt.c_str()) == 0);
			if (!found || sameExt)
			{
				foundAlgo = nextAlgo;
				listFormat = IsSfvAlgo(nextAlgo) ? HLF_SFV : HLF_SIMPLE;
				found = true;
			}
			
			if (sameExt) break;
		}
	}

	return found;
}

bool HashList::TryParseBSD( const char* inputStr, UINT codepage, FileHashInfo &fileInfo )
{
	const std::regex rx("^([\\w-]+)\\s+\\((.+)\\)\\s=\\s([A-Fa-f\\d]+)$");
	std::cmatch match;
	
	if (std::regex_match(inputStr, match, rx))
	{
		auto hashName = match[1].str();
		for (int i = 0; i < NUMBER_OF_SUPPORTED_HASHES; i++)
		{
			//TODO: get custom bsd names from rhash code
			rhash_ids algoId = SupportedHashes[i].AlgoId;
			if (_stricmp(hashName.c_str(), rhash_get_name(algoId)) == 0)
			{
				fileInfo.Filename = ConvertToUnicode(match[2].str(), codepage);
				fileInfo.HashStr = match[3].str();
				fileInfo.HashAlgo = algoId;
				
				return true;
			}
		}
	}
	
	return false;
}

bool HashList::TryParseSimple( const char* inputStr, UINT codepage, rhash_ids hashAlgo, FileHashInfo &fileInfo )
{
	const std::regex rx("^([A-Fa-f\\d]{32,128})\\s[\\s*]((?:\\\\\\\\\\?\\\\)?[^<>|?*\\n]+)$");
	std::cmatch match;

	if (std::regex_match(inputStr, match, rx))
	{
		auto strPath = match[2].str();
		auto strHash = match[1].str();
		
		if (strHash.length() == rhash_get_hash_length(hashAlgo))
		{
			fileInfo.Filename = ConvertToUnicode(strPath, codepage);
			fileInfo.HashStr = strHash;
			fileInfo.HashAlgo = hashAlgo;

			return true;
		}
	}

	return false;
}

bool HashList::TryParseSfv(const char* inputStr, UINT codepage, rhash_ids hashAlgo, FileHashInfo &fileInfo)
{
	const std::regex rx("^([^<>|?*\\n]+?)\\s+([A-Fa-f\\d]{8})$");
	std::cmatch match;

	if (std::regex_match(inputStr, match, rx))
	{
		auto strPath = match[1].str();
		auto strHash = match[2].str();

		if (strHash.length() == rhash_get_hash_length(hashAlgo))
		{
			fileInfo.Filename = ConvertToUnicode(strPath, codepage);
			fileInfo.HashStr = strHash;
			fileInfo.HashAlgo = hashAlgo;

			return true;
		}
	}

	return false;
}

//////////////////////////////////////////////////////////////////////////

std::wstring FileHashInfo::ToString() const
{
	std::wstringstream sstr;

	if (IsSfvAlgo(HashAlgo))
		sstr << Filename << L" " << ConvertToUnicode(HashStr, CP_UTF8);
	else
		sstr << ConvertToUnicode(HashStr, CP_UTF8) << L" *" << Filename;

	return sstr.str();
}

void FileHashInfo::Serialize( std::stringstream& dest, UINT codepage, bool stripFilePath) const
{
	char szFilenameBuf[PATH_BUFFER_SIZE] = {0};

	const wchar_t* wszInputPath = Filename.c_str();
	if (stripFilePath)
	{
		const wchar_t* wszLastSlash = wcsrchr(wszInputPath, L'\\');
		wszInputPath = wszLastSlash ? wszLastSlash + 1 : wszInputPath;
	}

	WideCharToMultiByte(codepage, 0, wszInputPath, -1, szFilenameBuf, ARRAY_SIZE(szFilenameBuf), NULL, NULL);
	if (IsSfvAlgo(HashAlgo))
		dest << szFilenameBuf << " " << HashStr;
	else
		dest << HashStr << " *" << szFilenameBuf;
}

//////////////////////////////////////////////////////////////////////////

size_t FileReadBufferSize = 64 * 1024;

GenResult GenerateHash(const std::wstring& filePath, std::vector<rhash_ids> hashAlgos, std::vector<std::string> &results, bool useUppercase, HashingProgressFunc progressFunc, HANDLE progressContext)
{
	if (hashAlgos.size() == 0)
		return GenResult::Error;
	
	auto strUniPath = PrependLongPrefix(filePath);
	
	HANDLE hFile = CreateFile(strUniPath.c_str(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, 0);
	if (hFile == INVALID_HANDLE_VALUE) return GenResult::Error;

	char *readBuf = (char*) malloc(FileReadBufferSize);
	DWORD numReadBytes;

	GenResult retVal = GenResult::Success;
	int64_t totalBytes = GetFileSize_i64(hFile);

	rhash_ids algo = (rhash_ids) 0;
	for (rhash_ids nextAlgo : hashAlgos)
	{
		algo = (rhash_ids) (algo | nextAlgo);
	}

	rhash hashCtx = rhash_init(algo);
	while (retVal == GenResult::Success && totalBytes > 0)
	{
		if (!ReadFile(hFile, readBuf, (DWORD) FileReadBufferSize, &numReadBytes, NULL) || !numReadBytes)
		{
			retVal = GenResult::Error;
			break;
		}

		totalBytes -= numReadBytes;
		rhash_update(hashCtx, readBuf, numReadBytes);

		if (progressFunc != NULL)
		{
			if (!progressFunc(progressContext, numReadBytes))
				retVal = GenResult::Aborted;
		}
	}
	
	if (retVal == GenResult::Success)
	{
		int printFlags = RHPR_HEX;
		if (useUppercase) printFlags = printFlags | RHPR_UPPERCASE;

		rhash_final(hashCtx, NULL);

		char tmpBuf[256] = { 0 };
		for (auto nextAlgo : hashAlgos)
		{
			rhash_print(tmpBuf, hashCtx, nextAlgo, printFlags);
			results.push_back(tmpBuf);
		}
	}

	rhash_free(hashCtx);
	CloseHandle(hFile);
	free(readBuf);

	return retVal;
}

GenResult GenerateHash(const std::wstring& filePath, rhash_ids hashAlgo, std::string& result, bool useUppercase, HashingProgressFunc progressFunc, HANDLE progressContext)
{
	std::vector<rhash_ids> algos;
	algos.push_back(hashAlgo);

	std::vector<std::string> results;

	GenResult retVal = GenerateHash(filePath, algos, results, useUppercase, progressFunc, progressContext);

	if (results.size() > 0)
	{
		result = results[0];
	}

	return retVal;
}

std::vector<int> DetectHashAlgo(const std::string &testStr)
{
	std::vector<int> algoIndicies;

	// Check if it can be hash at all
	bool canBeHash = std::find_if(testStr.begin(), testStr.end(), [](unsigned char c) { return !std::isxdigit(c); }) == testStr.end();
	if (canBeHash)
	{
		// Go through all hashes and check string size
		for (int i = 0; i < NUMBER_OF_SUPPORTED_HASHES; i++)
		{
			if (rhash_get_hash_length(SupportedHashes[i].AlgoId) == testStr.length())
				algoIndicies.push_back(i);
		}
	}
	
	return algoIndicies;
}

bool SameHash(const std::string& hash1, const std::string& hash2)
{
	return _stricmp(hash1.c_str(), hash2.c_str()) == 0;
}

static int8_t* CreateRandomBuffer(size_t bufferSize)
{
	int8_t* buffer = (int8_t*)malloc(bufferSize);

	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<> dist(0, 255);

	for (size_t i = 0; i < bufferSize; ++i)
	{
		buffer[i] = dist(gen);
	}

	return buffer;
}

int64_t BenchmarkAlgorithm(rhash_ids algo, size_t dataSize, size_t bufferSize)
{
	typedef std::chrono::system_clock clock_type;
	
	int8_t* dataBuffer = CreateRandomBuffer(bufferSize);
	auto start_time = clock_type::now();

	rhash hashCtx = rhash_init(algo);
	int64_t dataLeft = (int64_t) dataSize;
	while (dataLeft > 0)
	{
		rhash_update(hashCtx, dataBuffer, bufferSize);
		dataLeft -= bufferSize;

		if (CheckEsc())
			return -1;
	}
	rhash_final(hashCtx, nullptr);

	auto end_time = clock_type::now();
	auto calc_time = end_time - start_time;

	free(dataBuffer);

	return std::chrono::duration_cast<std::chrono::milliseconds>(calc_time).count();
}
